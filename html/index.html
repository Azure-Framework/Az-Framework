<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>HUD â€” Glass Blue (No Black Veil)</title>

  <!-- Inter font + bootstrap icons -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">

  <style>
    :root{
      --accent-color: #3fb4ff;
      --accent-2: #4ab8ff;
      --text-primary: #eaf6ff;
      --text-secondary: #9fc0dc;
      --hud-gap: 12px;
      --hud-padding: 10px 14px;
      --hud-radius: 12px;
      --hud-shadow: 0 8px 30px rgba(30,60,110,0.14);
      --font-family: "Inter", system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    }

    html, body {
      height:100%;
      background: transparent !important;
      color:var(--text-primary);
      margin:0; padding:0;
      font-family:var(--font-family);
      overflow:hidden;
    }
    * { box-sizing:border-box; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }

    /* HUD container */
    #hudContainer{
      position: absolute;
      top: 20px;
      right: 20px;
      display:flex;
      gap:var(--hud-gap);
      align-items:center;
      user-select:none;
      cursor:default;
      z-index:2200;
      transition: right .18s ease, top .18s ease;
      pointer-events:auto;
    }
    #hudContainer.move-mode{
      cursor:grab;
      outline: 1px dashed rgba(63,180,255,0.20);
      outline-offset: 6px;
    }

    /* Card â€” translucent bluish cards */
    .hud-card{
      display:flex;
      align-items:center;
      gap:12px;
      padding:var(--hud-padding);
      min-height:46px;
      border-radius:var(--hud-radius);
      background: linear-gradient(180deg, rgba(14,30,48,0.56), rgba(8,18,30,0.48));
      border: 1px solid rgba(255,255,255,0.03);
      box-shadow: var(--hud-shadow);
      transition: transform .18s ease, box-shadow .18s ease, opacity .18s ease;
      position: relative;
      overflow: visible;
      min-width:120px;
      isolation:isolate;
    }
    .hud-card.dragging{ cursor:grabbing; z-index:3000; transform:scale(1.02); box-shadow:0 20px 40px rgba(20,50,120,0.22); }
    .hud-card:hover{ transform: translateY(-4px); box-shadow: 0 18px 40px rgba(25,60,130,0.16); }

    .hud-card::before{
      content:'';
      position:absolute; left:0; top:0; bottom:0;
      width:4px;
      border-top-left-radius:var(--hud-radius); border-bottom-left-radius:var(--hud-radius);
      background: linear-gradient(180deg, var(--accent-color), var(--accent-2));
      box-shadow: 0 0 12px rgba(63,180,255,0.06);
    }

    /* Icon */
    .hud-icon{
      width:36px; height:36px; border-radius:10px;
      display:flex; align-items:center; justify-content:center;
      background: rgba(255,255,255,0.015);
      border: 1px solid rgba(255,255,255,0.02);
      box-shadow: inset 0 -6px 12px rgba(0,0,0,0.12);
      flex-shrink:0;
    }
    .hud-icon i { font-size:18px; color:var(--accent-color); }

    /* server logo */
    #serverLogo img{
      height:36px; width:auto; display:block;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.03);
      box-shadow: 0 6px 18px rgba(20,40,80,0.12);
      background: transparent;
    }
    #serverLogo{ padding:8px; min-width:44px; justify-content:center; background:transparent; }

    .hud-content{ display:flex; flex-direction:column; gap:2px; min-width:0; }
    .hud-label{ font-size:10px; color:var(--text-secondary); letter-spacing:0.06em; text-transform:uppercase; }
    .hud-value{ font-size:15px; color:var(--text-primary); font-weight:700; white-space:nowrap; text-overflow:ellipsis; overflow:hidden; max-width:240px; }

    .value-update{ animation: pulse .9s ease-in-out; }
    @keyframes pulse{ 0%{ transform:translateY(0); } 50%{ transform:translateY(-2px); } 100%{ transform:translateY(0); } }

    /* Overlay panels â€” these will be positioned near the HUD while in move-mode */
    .overlay-panel, .overlay-paneltoggle{
      position: absolute;
      left: 0;
      top: 0;
      width: 320px;
      max-width: 92vw;
      padding:12px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(12,26,40,0.62), rgba(8,16,28,0.52));
      border: 1px solid rgba(255,255,255,0.02);
      box-shadow: 0 12px 36px rgba(6,20,50,0.14);
      color:var(--text-primary);
      display:none;
      z-index:2400;
      transform-origin:center;
      transition: transform .16s cubic-bezier(.2,.9,.2,1), opacity .16s ease;
      pointer-events:auto;
      backdrop-filter: none;
    }
    .overlay-panel h3, .overlay-paneltoggle h3{
      color:var(--accent-color);
      margin-bottom:8px;
      font-size:15px;
      letter-spacing:0.01em;
    }
    .overlay-panel ul{ list-style:none; padding-left:0; margin-top:6px; color:var(--text-secondary); }
    .overlay-panel li{ margin:8px 0; font-size:14px; }

    /* settings items */
    #settings ul{ display:flex; flex-direction:column; gap:8px; padding:0; margin:0; }
    #settings label{
      display:flex; align-items:center; gap:10px; cursor:pointer; user-select:none;
      font-size:14px; color:var(--text-primary);
    }
    #settings input[type="checkbox"]{ width:18px; height:18px; accent-color:var(--accent-color); }

    /* Save/Cancel row */
    #settingsButtons{ display:flex; gap:8px; margin-top:10px; justify-content:flex-end; }
    #saveHUD, #cancelHUD{
      padding:8px 12px; border-radius:10px; border:none; font-weight:700; cursor:pointer;
      box-shadow: 0 8px 18px rgba(10,30,60,0.12);
    }
    #saveHUD{ background: linear-gradient(90deg,var(--accent-color),var(--accent-2)); color:#042033; }
    #cancelHUD{ background: transparent; color:var(--text-primary); border:1px solid rgba(255,255,255,0.03); }

    #resetHUD{
      margin-top:8px;
      padding:8px 10px;
      border-radius:10px;
      border:none;
      font-weight:700;
      background: rgba(255,255,255,0.02);
      color:var(--text-primary);
      cursor:pointer;
    }

    @media (max-width:560px){
      #hudContainer{ gap:8px; top:12px; right:12px; }
      .hud-card{ padding:8px; min-width:100px; }
      .hud-icon{ width:30px; height:30px; }
      .hud-value{ font-size:13px; }
      .overlay-panel, .overlay-paneltoggle{ width:92vw; left:4vw; }
    }
  </style>
</head>
<body>

  <!-- HUD -->
  <div id="hudContainer" role="application" aria-label="HUD Container">
    <div class="hud-card" id="serverLogo">
      <img src="https://imgimp.xyz/images/Stoic-2025-06-28_06-06-19-685f865b90047.png" alt="Server Logo">
    </div>

    <!-- PLAYER NAME (new) -->
    <div class="hud-card" id="card-player">
      <div class="hud-icon"><i class="bi bi-person-circle"></i></div>
      <div class="hud-content">
        <div class="hud-label">Player</div>
        <div class="hud-value" id="playerNameDisplay">No Name</div>
      </div>
    </div>

    <div class="hud-card" id="card-discord">
      <div class="hud-icon"><i class="bi bi-chat-dots"></i></div>
      <div class="hud-content">
        <div class="hud-label">Discord</div>
        <div class="hud-value">discord.gg/QWWWV6Zyaa</div>
      </div>
    </div>

    <div class="hud-card" id="card-job">
      <div class="hud-icon"><i class="bi bi-briefcase"></i></div>
      <div class="hud-content">
        <div class="hud-label">Job</div>
        <div class="hud-value" id="jobDisplay">Unemployed</div>
      </div>
    </div>

    <div class="hud-card" id="card-cash">
      <div class="hud-icon"><i class="bi bi-wallet2"></i></div>
      <div class="hud-content">
        <div class="hud-label">Cash</div>
        <div class="hud-value value-update" id="cashDisplay">$0</div>
      </div>
    </div>

    <div class="hud-card" id="card-bank">
      <div class="hud-icon"><i class="bi bi-bank"></i></div>
      <div class="hud-content">
        <div class="hud-label">Bank</div>
        <div class="hud-value value-update" id="bankDisplay">$0</div>
      </div>
    </div>
  </div>

  <!-- SETTINGS (anchored programmatically near HUD while in move-mode) -->
  <div id="settings" class="overlay-paneltoggle" aria-hidden="true">
    <h3>HUD Settings</h3>
    <ul>
      <li><label><input type="checkbox" data-target="serverLogo"> Server Logo</label></li>
      <li><label><input type="checkbox" data-target="card-player"> Player Name</label></li>
      <li><label><input type="checkbox" data-target="card-discord"> Discord</label></li>
      <li><label><input type="checkbox" data-target="card-job"> Job</label></li>
      <li><label><input type="checkbox" data-target="card-cash"> Cash</label></li>
      <li><label><input type="checkbox" data-target="card-bank"> Bank</label></li>
    </ul>

    <div id="settingsButtons">
      <button id="cancelHUD">Cancel</button>
      <button id="saveHUD">Save</button>
    </div>

    <button id="resetHUD">ðŸ”„ Reset to Default</button>
  </div>

  <!-- GUIDE -->
  <div id="guide" class="overlay-panel" aria-hidden="true">
    <h3>HUD Move Guide</h3>
    <ul>
      <li>Drag anywhere to move the whole HUD.</li>
      <li>Hold <strong>Ctrl</strong> + drag a card to move a single card.</li>
      <li>Click <strong>Save</strong> to keep your layout, or <strong>Cancel</strong> to revert.</li>
      <li>Press <strong>Esc</strong> to exit move-mode (acts like Cancel).</li>
    </ul>
  </div>

  <!-- Admin Login -->
  <div id="adminLogin" style="display:none; position:absolute; inset:0; pointer-events:none; background:transparent; z-index:2600;">
    <div class="panel" style="width:320px; margin:auto; pointer-events:auto; top:20vh; position:relative;">
      <h2 style="color:var(--accent-color); margin-bottom:12px; font-size:18px">Admin Login</h2>
      <input type="password" placeholder="Enter Password" id="adminPassword" autocomplete="off" style="width:100%; padding:10px; margin-bottom:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.02); background: rgba(255,255,255,0.01); color:var(--text-primary);">
      <button id="adminSubmit" style="width:100%; padding:10px; border-radius:10px; border:none; background: linear-gradient(90deg,var(--accent-color),var(--accent-2)); color:#042033; font-weight:700;">Login</button>
    </div>
  </div>

  <script>
    if (typeof GetParentResourceName === 'undefined') {
      window.GetParentResourceName = () => 'az-fw-hud';
    }

    /* small cookie helpers */
    function setCookie(name, value, days = 365) {
      const expires = new Date(Date.now() + days * 864e5).toUTCString();
      document.cookie = name + '=' + encodeURIComponent(value) + '; expires=' + expires + '; path=/';
    }
    function getCookie(name) {
      return document.cookie.split('; ').reduce((r, c) => {
        const [k, v] = c.split('=');
        return k === name ? decodeURIComponent(v) : r;
      }, '');
    }

    const hud      = document.getElementById('hudContainer');
    const guide    = document.getElementById('guide');
    const settings = document.getElementById('settings');
    const cards    = Array.from(document.querySelectorAll('.hud-card'));
    const toggles  = settings.querySelectorAll('input[type=checkbox]');

    // snapshot helpers
    let initialSnapshot = null;
    function snapshotCurrentState() {
      const rect = hud.getBoundingClientRect();
      const hudRight = parseInt(hud.style.right) || Math.round(window.innerWidth - rect.right);
      const hudTop = parseInt(hud.style.top) || Math.round(rect.top);
      const cardsState = {};
      cards.forEach(card => {
        cardsState[card.id] = {
          display: card.style.display || '',
          position: card.style.position || '',
          left: card.style.left || '',
          top: card.style.top || '',
          width: card.style.width || '',
          height: card.style.height || ''
        };
      });
      return { hudRight, hudTop, cardsState };
    }

    function positionOverlaysNearHUD() {
      const rect = hud.getBoundingClientRect();
      if (!rect.width) return;
      const preferLeft = rect.left > 380;
      const below = (rect.bottom + 12 + 200) < window.innerHeight;
      settings.style.left = (preferLeft ? rect.left - 340 : rect.right + 12) + 'px';
      settings.style.top  = (below ? rect.top : Math.max(8, rect.top - 220)) + 'px';
      guide.style.left = (rect.left + (rect.width / 2) - 160) + 'px';
      guide.style.top  = (rect.bottom + 12) + 'px';
      [settings, guide].forEach(el => {
        const r = el.getBoundingClientRect();
        if (r.right > window.innerWidth - 8) {
          el.style.left = (parseFloat(el.style.left) - (r.right - window.innerWidth) - 8) + 'px';
        }
        if (r.left < 8) el.style.left = '8px';
      });
    }

    function updateOverlays() {
      const on = hud.classList.contains('move-mode');
      settings.style.display = on ? 'block' : 'none';
      guide.style.display = on ? 'block' : 'none';
      positionOverlaysNearHUD();
      settings.setAttribute('aria-hidden', !on);
      guide.setAttribute('aria-hidden', !on);
    }

    function toggleMoveMode() {
      const enabling = !hud.classList.contains('move-mode');
      if (enabling) {
        initialSnapshot = snapshotCurrentState();
        hud.classList.add('move-mode');
        updateOverlays();

      // initialize toggle checkboxes and attach change handlers so they remove/show elements
      toggles.forEach(box => {
        const id = box.dataset.target;
        const el = document.getElementById(id);
        // default checked from cookie (treat absent cookie as checked)
        box.checked = (getCookie('hud_' + id) !== '0') ? true : (getCookie('hud_' + id) === '1');
        // Ensure element visibility matches checkbox state
        if (el) el.style.display = box.checked ? '' : 'none';

        box.addEventListener('change', () => {
          if (!el) return;
          if (box.checked) {
            el.style.display = '';
            setCookie('hud_' + id, '1');
          } else {
            // remove/hide the element when toggled off
            el.style.display = 'none';
            setCookie('hud_' + id, '0');
          }
          // reposition overlays in case HUD size changed
          positionOverlaysNearHUD();
        });
      });

        positionOverlaysNearHUD();
      } else {
        cancelMoveMode();
      }
    }

    function cancelMoveMode() {
      if (!initialSnapshot) {
        hud.classList.remove('move-mode');
        updateOverlays();
        return;
      }
      hud.style.right = (initialSnapshot.hudRight ?? 20) + 'px';
      hud.style.top   = (initialSnapshot.hudTop  ?? 20) + 'px';
      for (const id in initialSnapshot.cardsState) {
        const s = initialSnapshot.cardsState[id];
        const el = document.getElementById(id);
        if (!el) continue;
        el.style.display = s.display;
        el.style.position = s.position;
        el.style.left = s.left;
        el.style.top  = s.top;
        el.style.width = s.width;
        el.style.height = s.height;
        el.classList.remove('dragging');
      }
      hud.classList.remove('move-mode');
      updateOverlays();
      initialSnapshot = null;
      try { fetch(`https://${GetParentResourceName()}/closeUI`, { method: 'POST' }); } catch(e){}
    }

    // --- dragging logic (whole hud and per-card) ---
    let containerDrag = false, containerStart = {};
    let cardDrag = null, cardStart = {}, hudRect = {};

    hud.addEventListener('mousedown', e => {
      if (!hud.classList.contains('move-mode') || e.ctrlKey) return;
      containerDrag = true;
      containerStart = {
        x: e.clientX,
        y: e.clientY,
        right: parseInt(hud.style.right) || 20,
        top:   parseInt(hud.style.top)   || 20
      };
      document.addEventListener('mousemove', onHudMove);
      document.addEventListener('mouseup',   onHudUp);
    });

    function onHudMove(e) {
      if (!containerDrag) return;
      const dx = e.clientX - containerStart.x;
      const dy = e.clientY - containerStart.y;
      hud.style.right = (containerStart.right - dx) + 'px';
      hud.style.top   = (containerStart.top   + dy) + 'px';
      positionOverlaysNearHUD();
    }

    function onHudUp() {
      if (!containerDrag) return;
      containerDrag = false;
      document.removeEventListener('mousemove', onHudMove);
      document.removeEventListener('mouseup',   onHudUp);
      positionOverlaysNearHUD();
    }

    cards.forEach(card => {
      card.addEventListener('mousedown', e => {
        if (!hud.classList.contains('move-mode') || !e.ctrlKey) return;
        e.preventDefault(); e.stopPropagation();

        cardDrag = card;
        hudRect = hud.getBoundingClientRect();
        const rect = card.getBoundingClientRect();
        cardStart = {
          offsetX: e.clientX - rect.left,
          offsetY: e.clientY - rect.top,
          left:    rect.left  - hudRect.left,
          top:     rect.top   - hudRect.top
        };

        card.style.position = 'absolute';
        card.style.width    = rect.width + 'px';
        card.style.height   = rect.height + 'px';
        card.classList.add('dragging');
        card.style.left = cardStart.left + 'px';
        card.style.top  = cardStart.top  + 'px';

        document.addEventListener('mousemove', onCardMove);
        document.addEventListener('mouseup',   onCardUp);
      });
    });

    function onCardMove(e) {
      if (!cardDrag) return;
      const x = e.clientX - hudRect.left - cardStart.offsetX;
      const y = e.clientY - hudRect.top  - cardStart.offsetY;
      cardDrag.style.left = Math.max(0, Math.round(x)) + 'px';
      cardDrag.style.top  = Math.max(0, Math.round(y)) + 'px';
      positionOverlaysNearHUD();
    }

    function onCardUp() {
      if (!cardDrag) return;
      try {
        const rect = cardDrag.getBoundingClientRect();
        const left = Math.round(rect.left - hud.getBoundingClientRect().left);
        const top  = Math.round(rect.top  - hud.getBoundingClientRect().top);
        // include current position so we can reapply it later
        localStorage.setItem('hud_pos_' + cardDrag.id, JSON.stringify({
          left: left,
          top: top,
          width: cardDrag.style.width || '',
          height: cardDrag.style.height || '',
          position: cardDrag.style.position || 'absolute'
        }));
      } catch(e){}
      cardDrag.classList.remove('dragging');
      cardDrag = null;
      document.removeEventListener('mousemove', onCardMove);
      document.removeEventListener('mouseup',   onCardUp);
      positionOverlaysNearHUD();
    }

    window.addEventListener('resize', positionOverlaysNearHUD);

    // Expose toggleHudMoveMode globally
    window.toggleHudMoveMode = toggleMoveMode;

    // Update helpers used by messages
    function updateHudPlayerName(name) {
      const el = document.getElementById('playerNameDisplay');
      if (!el) return;
      el.textContent = name && name.length ? name : 'No Name';
    }
    window.updateHudPlayerName = updateHudPlayerName;
    window.updateHudCash = (cash, bank, playerName) => {
      if (cash !== undefined) document.getElementById('cashDisplay').textContent = `$${cash}`;
      if (bank !== undefined) document.getElementById('bankDisplay').textContent = `$${bank}`;
      if (playerName) updateHudPlayerName(playerName);
    };
    window.updateHudJob = (job, playerName) => {
      document.getElementById('jobDisplay').textContent = job || 'Unemployed';
      if (playerName) updateHudPlayerName(playerName);
    };

    // Reset button â€” clears local UI and asks client.lua to delete KVP
    document.getElementById('resetHUD').addEventListener('click', () => {
      cards.forEach(card => {
        document.cookie = `hud_${card.id}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
        localStorage.removeItem('hud_pos_' + card.id);
        card.style.display = '';
        card.style.position = '';
        card.style.top = '';
        card.style.left = '';
        card.style.width = '';
        card.style.height = '';
        card.classList.remove('dragging');
      });
      localStorage.removeItem('hudRight');
      localStorage.removeItem('hudTop');
      toggles.forEach(box => box.checked = true);

      fetch(`https://${GetParentResourceName()}/resetDefaults`, { method: 'POST' })
        .finally(() => {
          try { fetch(`https://${GetParentResourceName()}/closeUI`, { method: 'POST' }); } catch(e){}
        });
    });

    // Save button behaviour: gather payload and send to client to persist
    
    function saveHUDPos() {
      const rect = hud.getBoundingClientRect();
      localStorage.hudRight = Math.max(8, Math.round(window.innerWidth - rect.right));
      localStorage.hudTop   = Math.max(8, Math.round(rect.top));
    }

    document.getElementById('saveHUD').addEventListener('click', () => {
      saveHUDPos();

      const payload = {
        hudRight: localStorage.hudRight || 20,
        hudTop: localStorage.hudTop || 20,
        toggles: {},
        cards: {}
      };

      toggles.forEach(box => {
        const id = box.dataset.target;
        payload.toggles[id] = !!box.checked;
      });

      cards.forEach(card => {
        const id = card.id;
        const raw = localStorage.getItem('hud_pos_' + id);
        let posObj = null;
        if (raw) {
          try { posObj = JSON.parse(raw); } catch(e){ posObj = null; }
        }
        const position = card.style.position || (posObj && posObj.position) || '';

        payload.cards[id] = {
          display: (card.style.display === 'none') ? 'none' : '',
          position: position,
          left: (posObj && posObj.left !== undefined) ? posObj.left : (parseInt(card.style.left) || 0),
          top:  (posObj && posObj.top  !== undefined) ? posObj.top  : (parseInt(card.style.top)  || 0),
          width: card.style.width || (posObj && posObj.width) || '',
          height: card.style.height || (posObj && posObj.height) || ''
        };
      });

      fetch(`https://${GetParentResourceName()}/saveHUD`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json; charset=UTF-8' },
        body: JSON.stringify(payload)
      })
      .then(() => {
        hud.classList.remove('move-mode');
        updateOverlays();
        cards.forEach(c => c.classList.remove('dragging'));
        try { fetch(`https://${GetParentResourceName()}/closeUI`, { method: 'POST' }); } catch(e){}
        initialSnapshot = null;
      })
      .catch(() => {
        hud.classList.remove('move-mode');
        updateOverlays();
        cards.forEach(c => c.classList.remove('dragging'));
        try { fetch(`https://${GetParentResourceName()}/closeUI`, { method: 'POST' }); } catch(e){}
        initialSnapshot = null;
      });
    });

    // Cancel handler
    document.getElementById('cancelHUD').addEventListener('click', cancelMoveMode);

    // Admin submit
    document.getElementById('adminSubmit').addEventListener('click', () => {
      const pass = document.getElementById('adminPassword').value;
      fetch(`https://${GetParentResourceName()}/adminAuth`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password: pass })
      }).then(() => {
        document.getElementById('adminLogin').style.display = 'none';
        document.getElementById('adminLogin').style.pointerEvents = 'none';
      });
    });

    // Request settings from client on load & apply local fallback after DOM ready
    window.addEventListener('DOMContentLoaded', () => {
      try { fetch(`https://${GetParentResourceName()}/requestSettings`, { method: 'POST' }).catch(()=>{}); } catch(e){}

      // apply cookie visibility and localStorage fallback *only after DOM is ready*
      cards.forEach(card => {
        const v = getCookie('hud_' + card.id);
        if (v === '0') card.style.display = 'none';
      });

      cards.forEach(card => {
        const raw = localStorage.getItem('hud_pos_' + card.id);
        if (raw) {
          try {
            const pos = JSON.parse(raw);
            if (pos.position && pos.position !== '') {
              card.style.position = pos.position;
            } else {
              if (pos.left !== undefined || pos.top !== undefined) card.style.position = 'absolute';
            }
            if (pos.left !== undefined) card.style.left = (pos.left + 'px');
            if (pos.top !== undefined)  card.style.top  = (pos.top  + 'px');
            if (pos.width) card.style.width = pos.width;
            if (pos.height) card.style.height = pos.height;
          } catch(e){}
        }
      });

      (function () {
        const r = parseInt(localStorage.hudRight) || 20;
        const t = parseInt(localStorage.hudTop)   || 20;
        hud.style.right = r + 'px';
        hud.style.top   = t + 'px';
      })();

      updateOverlays();
    });

    // NUI messages from client.lua
    window.addEventListener('message', ev => {
      const d = ev.data;
      if (!d) return;

      if (d.action === 'loadSettings') {
        const s = d.settings;
        if (!s) return;

        // Defer to next frame so layout measurements are stable
        requestAnimationFrame(() => {
          try {
            // apply HUD container first
            if (s.hudRight !== undefined) hud.style.right = (parseInt(s.hudRight) || 20) + 'px';
            if (s.hudTop !== undefined)  hud.style.top   = (parseInt(s.hudTop)  || 20) + 'px';

            // toggles: apply visibility & cookie only if explicitly provided
            if (s.toggles && typeof s.toggles === 'object') {
              for (const k in s.toggles) {
                const cb = settings.querySelector(`input[data-target="${k}"]`);
                const el = document.getElementById(k);
                if (cb && el) {
                  cb.checked = !!s.toggles[k];
                  el.style.display = cb.checked ? '' : 'none';
                  setCookie('hud_' + k, cb.checked ? '1' : '0');
                }
              }
            }

            // cards: only set left/top when numbers are present
            if (s.cards && typeof s.cards === 'object') {
              for (const id in s.cards) {
                const pos = s.cards[id];
                const el = document.getElementById(id);
                if (!el || !pos) continue;

                // visibility: explicit
                if (pos.display === 'none') {
                  el.style.display = 'none';
                  document.cookie = `hud_${id}=0; path=/; max-age=${365*24*60*60}`;
                } else {
                  el.style.display = '';
                  document.cookie = `hud_${id}=1; path=/; max-age=${365*24*60*60}`;
                }

                // position: apply only if provided; enforce absolute when left/top exist
                if (pos.left !== undefined || pos.top !== undefined) {
                  el.style.position = (pos.position && pos.position !== '') ? pos.position : 'absolute';
                } else if (pos.position && pos.position !== '') {
                  el.style.position = pos.position;
                }

                // only apply numeric coordinates if present and valid
                if (pos.left !== undefined && pos.left !== null && pos.left !== '') {
                  const left = Number(pos.left);
                  if (!Number.isNaN(left)) el.style.left = Math.round(left) + 'px';
                }
                if (pos.top !== undefined && pos.top !== null && pos.top !== '') {
                  const top = Number(pos.top);
                  if (!Number.isNaN(top)) el.style.top = Math.round(top) + 'px';
                }
                if (pos.width)  el.style.width  = pos.width;
                if (pos.height) el.style.height = pos.height;

                // persist only valid numeric values to localStorage (avoid overwriting good values with invalid ones)
                try {
                  const existing = JSON.parse(localStorage.getItem('hud_pos_' + id) || 'null');
                  const storeObj = {
                    left: (pos.left !== undefined && pos.left !== null && pos.left !== '') ? parseInt(pos.left) : (existing ? existing.left : undefined),
                    top:  (pos.top  !== undefined && pos.top  !== null && pos.top  !== '') ? parseInt(pos.top)  : (existing ? existing.top  : undefined),
                    width: pos.width || (existing ? existing.width : ''),
                    height: pos.height || (existing ? existing.height : ''),
                    position: el.style.position || (existing ? existing.position : '')
                  };
                  localStorage.setItem('hud_pos_' + id, JSON.stringify(storeObj));
                } catch (e) { /* ignore storage errors */ }
              }
            }

            if (s.hudRight !== undefined) localStorage.hudRight = s.hudRight;
            if (s.hudTop !== undefined)  localStorage.hudTop  = s.hudTop;

            positionOverlaysNearHUD();
          } catch (e) {
            console.warn('Error applying saved HUD settings', e);
          }
        });

        return;
      }

      switch (d.action) {
        case 'toggleMove': toggleMoveMode(); break;
        case 'updateCash':
          if (d.cash !== undefined) document.getElementById('cashDisplay').textContent = `$${d.cash}`;
          if (d.bank !== undefined) document.getElementById('bankDisplay').textContent = `$${d.bank}`;
          if (d.playerName) updateHudPlayerName(d.playerName);
          break;
        case 'updateCashOnly':
          document.getElementById('cashDisplay').textContent = `$${d.cash}`;
          if (d.playerName) updateHudPlayerName(d.playerName);
          break;
        case 'updateJob':
          document.getElementById('jobDisplay').textContent = d.job;
          break;
        case 'updatePlayerName':
          updateHudPlayerName(d.playerName || '');
          break;
        case 'openAdmin':
          document.getElementById('adminLogin').style.display = 'flex';
          document.getElementById('adminLogin').style.pointerEvents = 'auto';
          break;
        case 'saved':
          try { fetch(`https://${GetParentResourceName()}/closeUI`, { method: 'POST' }).catch(()=>{}); } catch(e){}
          break;
      }
    });

    // Exit on Escape
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape' && hud.classList.contains('move-mode')) {
        cancelMoveMode();
      }
    });

    // init overlays
    updateOverlays();
  </script>
</body>
</html>
